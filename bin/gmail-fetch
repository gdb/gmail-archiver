#!/usr/bin/env ruby
require 'fileutils'
require 'net/imap'
require 'optparse'
require 'time'

require 'rubygems'
require 'highline/import'

require File.expand_path(File.join(File.dirname(__FILE__), '../lib/gmail-archiver'))

module GmailArchiver
  class OutOfMessages < StandardError; end

  class GmailFetchRunner < AbstractRunner
    include StripeContext::Log::Loggable

    def slice_size
      100
    end

    def initialize(username, password, options)
      @username = username
      @password = password
      @options = options
    end

    def db_file
      path('imap.db')
    end

    def login
      if @imap
        @imap.logout
        @imap.disconnect
      end

      log_ann('Connecting to imap.gmail.com')
      @imap = Net::IMAP.new('imap.gmail.com', 993, true)
      log_ann('Authenticating')
      @imap.login(@username, @password)
    end

    def select
      log_ann('Selecting all mail')
      @imap.select('[Gmail]/All Mail')
    end

    def max_id
      @db['max_id'] || 0
    end

    def update_max_id(uid)
      assert(uid >= max_id, "Uid is #{uid} but max_id is #{max_id}")
      @db['max_id'] = [max_id, uid].max
    end

    def store_message(uid, contents)
      safe = uid

      folder = path("messages/#{uid / 1000}")
      file = uid.to_s
      assert(!file.include?('/'), "Filename includes a /: #{file}", true)
      location = File.join(folder, file)

      log_ann("Dumping #{uid} to #{location}")
      FileUtils.mkdir_p(folder)
      File.open(location, 'w') do |f|
        f.write(contents)
      end
    end

    def fetch_next_slice
      last = max_id + slice_size
      slice = (max_id+1..last)

      log_ann("Fetching messages #{slice}")
      unless result = @imap.uid_fetch(slice, ['RFC822', 'UID'])
        if @options[:max_known] && last < @options[:max_known]
          log_warn("Empty slice found (slice ending at #{last}, max_known is #{@options[:max_known].inspect})")
          result = []
        else
          log_ann("No messages found (slice ending at #{last}, max_known is #{@options[:max_known].inspect})")
          raise OutOfMessages # might happen with an empty slice that isn't at the end; be careful
        end
      end

      update_max_id(last)
      result
    end

    def store_next_slice(result)
      log_ann("Storing #{result.length} messages")
      result.each do |message|
        uid = message.attr['UID'].to_i
        contents = message.attr['RFC822']

        store_message(uid, contents)
      end
    end

    def do_run
      log_ann("Starting fetch of all slices past #{max_id}")
      # @storer = start_storer
      begin
        login
        select

        while true
          benchmark do
            result = fetch_next_slice
            store_next_slice(result)
            result.length
          end
          checkpoint_db
        end
      rescue OutOfMessages
      rescue EOFError => e # imap lib dying
        log_error("Error; about to sleep and retry", e)
        sleep(10)
        retry
      end

      checkpoint_db
    end
  end
end

def main
  options = {}
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options]"

    opts.on('-v', '--verbosity', 'Verbosity of debugging output') do
      $log.level -= 1
    end

    opts.on('-c', '--cache', 'Enable caching of credentials in /tmp') do
      options[:cache] = true
    end

    opts.on('-m MAX', '--max-known MAX', 'The largest known UID') do |max|
      options[:max_known] = Integer(max)
    end

    opts.on('-h', '--help', 'Display this message') do
      puts opts
      exit(1)
    end
  end
  optparse.parse!

  if ARGV.length != 0
    puts optparse
    return 1
  end

  username = File.read('/tmp/username.txt').strip rescue nil
  unless username
    username = ask("Enter your email:  ")
    File.open('/tmp/username.txt', 'w', 0600) {|f| f.write(username)} if options[:cache]
  end

  password = File.read('/tmp/password.txt').strip rescue nil
  unless password
    password = ask("Enter your password:  ") { |q| q.echo = "*" }
    File.open('/tmp/password.txt', 'w', 0600) {|f| f.write(username)} if options[:cache]
  end

  runner = GmailArchiver::GmailFetchRunner.new(username, password, :max_known => options[:max_known])
  runner.run
  return 0
end

if $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
